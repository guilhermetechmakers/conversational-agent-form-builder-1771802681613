⚠️ CRITICAL EXECUTION RULES - READ FIRST ⚠️
❌ NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
❌ NEVER run: long-running processes, servers, or commands that don't exit
❌ NEVER test the application by starting it
✅ ALLOWED: npm install, npm run build, npm run test (if needed)
✅ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
⚠️ The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

=== DESIGN REFERENCE (MANDATORY) ===
# Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


*IMPORTANT*: For every page or component refer to # Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions
 for bestpractices and # Signup / Login

## Overview
Build a complete authentication system and public landing pages for the Conversational Agent Form Builder. This includes a combined Signup/Login entry page with email/password and SSO (Google, Microsoft, SAML) options, secure backend authentication and session management for users and admins, password reset flow via secure token links, email verification flow with resend and polling, and a marketing Landing Page with CTAs. All UI should follow the provided dark-mode, neon-accent design system and integrate into the project's agent/dashboard flow (successful auth redirects to Dashboard).

## Page Description (Full Detail)
This bundle comprises the Authentication entry (Signup / Login), Password Reset, Email Verification, and public Landing Page used by visitors and prospective customers.

What this page is:
- The Signup / Login page is the user's first entry point to create accounts or authenticate. It must support classic email/password flows and multiple SSO integrations (Google, Microsoft, SAML for enterprise).
- Password Reset page allows users to request a reset email and set a new password via a time-limited secure token.
- Email Verification page displayed after signup to instruct users to verify their email. It includes a resend verification button and a background polling mechanism to detect verification and auto-redirect.
- Landing Page is a public marketing page describing the product (agent form builder), value propositions, pricing, feature highlights, and CTAs to sign up or try a demo agent (public demo link).

Goals:
- Provide a secure, accessible, and friction-minimized onboarding/authentication experience that matches the product's modern, dark-mode aesthetic.
- Allow admins and regular users to log in, persist secure sessions, and handle SSO and password flows.
- Ensure email verification and password reset are secure (short-lived tokens, single-use links).
- Integrate redirects to Dashboard or demo agent links after successful auth.

Features connected:
- Core User Authentication: signup, login, logout, session handling (JWT or server session), role-based admin access, SSO flows.
- Email services: transactional emails for verification and password-reset (email templates consistent with design).
- Security and monitoring: rate limiting, account lockout for repeated failures, CAPTCHA (optional) on signup if needed.
- Audit logging for account events (signup, verify, login, failed logins, password reset).

UI elements & visual guidance:
- Auth Card: centered card on dark background (#1A1A1F / #141416), card background #202026 or #23232C, rounded 12-16px, subtle drop shadow, internal padding 24-28px.
- Header: product logo (left, neon accent), page title (Login or Create account) in white semibold (600).
- Tabs: two tabs to switch between Login and Signup (tabbed or segmented control). Active tab highlighted with neon green (#4FFF8F) underline or glow.
- Forms: Email input, password input, confirm password (only on signup), password strength meter (progress bar with color changes: red → yellow → green), inline validation messages in muted grey/red.
- SSO Buttons: pill-shaped buttons for Google, Microsoft, and "Enterprise SSO (SAML)". Each with an icon and subtle glow on hover (accent colors).
- Terms Checkbox: checkbox with link to Terms & Privacy, required on signup.
- Forgot Password: small link under login form to Password Reset page.
- Primary Action Buttons: pill-shaped, primary color neon green (#4FFF8F) for main actions, secondary grey buttons for alternatives.
- Success Toast/Redirect: short success toast in top-right with green accent then redirect to Dashboard (/dashboard) or previous intended URL.
- Password Reset Page: two sub-pages/views: (1) Request Reset: email input + submit; (2) Set New Password: accessed by secure link token. Both in same card style.
- Email Verification Page: card showing "Check your inbox", email displayed obfuscated, "Resend" button with cooldown, "Change email" link, and a background polling indicator (spinner + "Waiting for verification..."). Auto-redirect to Dashboard when verified.
- Landing Page: hero with product value props, feature cards, pricing CTA, testimonials, and actions: "Sign up" (redirect to Signup tab), "Try demo agent" (open a public demo agent in a new tab). Use neon accent highlights across hero and CTA buttons.

API integrations:
- No external API pre-connected in project context. Implement backend endpoints for authentication flows; provide hooks for external SMTP provider and SSO provider configs. Provide /auth/oauth endpoints that will integrate with OAuth providers (Google, Microsoft) and enterprise SAML via configuration.

## Components to Build
- AuthCard component: Tabbed container for Login and Signup forms with accessible keyboard navigation and animated tab indicator.
- EmailInput, PasswordInput components: inputs with inline validation, placeholder, label, tooltip, and password strength meter.
- SSOButtons component: Google, Microsoft, SAML button variants with icon, accessible labels, and click handlers.
- TermsCheckbox component: linked policy modal or external link, required enforcement.
- ForgotPasswordLink component: navigates to Password Reset Request view.
- PasswordStrengthMeter component: visual meter with color coding and textual hints.
- Toast / GlobalNotification component: success/error messages consistent with visual style.
- PasswordResetRequestView: email submission form.
- PasswordResetSetView: set new password, validate token, show time-left and reset result.
- EmailVerificationView: shows verified/unverified states, resend flow with cooldown, polling to backend for status.
- LandingPage components: Hero, FeaturesList, PricingCards, Testimonials, CTAs.
- API Client module: central HTTP client that handles session tokens, CSRF headers, and error handling.
- Route Guards: frontend route protection and redirect-to-login for protected routes.

## Implementation Requirements

### Frontend
- Stack: React (hooks), TypeScript, CSS-in-JS or Tailwind-like utility (deliver styled components that match design tokens). Use a router (React Router) and state management adequate for auth (Context or Redux).
- Pages:
  - /auth (default shows login tab, with ?tab=signup or #signup to deep link)
  - /auth/reset (request)
  - /auth/reset?token=<token> (set new password)
  - /auth/verify (Email Verification page)
  - / (Landing Page)
- Interactions:
  - Real-time input validation (email format, password policy: min 10 chars, include uppercase, lowercase, digit, special char)
  - Password strength meter updates as user types (visual + text).
  - Submit buttons disabled during requests; display loader animation.
  - SSO: clicking SSO buttons starts OAuth flow by opening /auth/oauth/:provider or redirecting. Support popup fallback.
  - On Signup success: show Email Verification page and prevent Dashboard access until verified (unless allow pre-verified access via setting).
  - Email Verification Page:
    - Poll endpoint /auth/me or /auth/verification-status every 5s (exponential backoff after several attempts) to detect when verified, then auto-redirect.
    - Resend button with 60s cooldown, show cooldown timer and success toast.
  - Password Reset:
    - Request: send email; show generic messaging (do not reveal whether email exists).
    - Set New Password: validate token with backend; show remaining time or invalid/expired flows, and link to request a new reset.
- Accessibility: All interactive elements keyboard accessible, proper aria-labels, form labels, error announcements.

### Backend
- Stack: Node.js + TypeScript (Express / Fastify / Nest recommended); SQL DB (Postgres) or similar. Provide SQL schema snippets and migration steps.
- Authentication:
  - Use secure password hashing (bcrypt with cost >=12 or argon2).
  - Issue sessions via HTTP-only, Secure cookies with SameSite=lax OR JWT stored in httpOnly cookies (refresh token pattern recommended).
  - Session inactivity TTL: configurable (recommend 14 days persistent, shorter for admin sessions).
  - Session revocation on logout.
- Email tokens:
  - Email verification tokens: cryptographically secure, single-use, expire in 24 hours.
  - Password reset tokens: cryptographically secure, single-use, expire in 1 hour.
  - Tokens stored hashed in DB (so if DB is compromised tokens are not usable).
- SSO:
  - OAuth2 flows for Google and Microsoft (server-side exchange using client secret).
  - SAML for enterprises: endpoint to receive SAML Assertion Consumer Service (ACS), map attributes to account or create new user with admin approval flow.
  - On SSO authentication, if email exists link provider to account; otherwise create user record and mark email as verified (for trusted providers).
- APIs:
  - /api/auth/signup (POST)
  - /api/auth/login (POST)
  - /api/auth/logout (POST)
  - /api/auth/me (GET)
  - /api/auth/password-reset/request (POST)
  - /api/auth/password-reset/confirm (POST) — token + new password
  - /api/auth/verify/resend (POST)
  - /api/auth/verify/check (GET) or use /api/auth/me
  - /api/auth/oauth/:provider (GET) — redirect to provider
  - /api/auth/oauth/:provider/callback (GET) — provider redirects here
  - /api/auth/saml/acs (POST) — SAML ACS
- DB tables:
  - users, auth_providers (SSO links), sessions, email_tokens (verification, reset), audit_logs
- Email sending:
  - Template engine for transactional emails with staging config and ability to plug SMTP / SES / SendGrid.
- Security:
  - Rate-limiting endpoints (signup, login, password reset) per IP and per account.
  - Account lockout after configurable failed attempts (e.g., 5 attempts in 15 minutes).
  - ReCAPTCHA or hCaptcha support on signup optionally, pluggable.
  - CSRF protection on state-changing endpoints (for cookie-based sessions).
  - Input validation and sanitization.
  - Proper CORS configuration for public client origins.
  - Logging and monitoring of suspicious auth activity.

### Integration
- Frontend and backend communicate over HTTPS using JSON API. The frontend should expect and handle the following:
  - 200/201 on success with structured body { success: true, data: {...} }.
  - 400 validation errors with { errors: [{ field, message }] }.
  - 401/403 for unauthorized/forbidden to trigger logout and redirect to login.
- On login/signup success:
  - Backend sets httpOnly cookie (session) or returns tokens.
  - Frontend calls /api/auth/me to fetch user profile and roles and uses route guard to navigate to /dashboard.
- SSO Integration:
  - Frontend triggers /api/auth/oauth/google (server returns redirect URL). For popup flow, the frontend opens a new window and polls for completion (postMessage or server-side session poll).
- Email Verification:
  - After signup, backend returns a status indicating verification required. Frontend shows EmailVerificationView with polling hitting /api/auth/verify/check or /api/auth/me.
- Password Reset:
  - Backend issues email with one-time link: https://<APP_HOST>/auth/reset?token=<token>. Frontend reads token from URL and calls /api/auth/password-reset/confirm.

## User Experience Flow
1. Landing Page visitor:
   - Sees hero with product summary and CTA "Sign up" and "Try demo agent".
   - Click "Try demo agent" opens public agent URL in new tab (no auth needed).
   - Click "Sign up" lands on /auth with signup tab active.
2. Signup:
   - User fills email, password, confirm password, accepts Terms.
   - Client validates inputs, shows password strength meter.
   - On submit, POST /api/auth/signup.
   - Backend creates user (password hashed), creates verification token, sends verification email, returns success.
   - Frontend navigates to /auth/verify and displays verification instructions. Show obfuscated email and resend button (60s cooldown).
3. Email Verification:
   - User clicks link in email → opens frontend route (/auth/verify?token=... or hits backend to verify token).
   - Backend verifies token, marks email_verified = true, logs event, and sets session cookie (optionally logs them in).
   - If user clicked email link, they should be auto-redirected to Dashboard.
   - If they remain on EmailVerificationView, background polling detects verification and redirects.
4. Login:
   - User selects Login tab, enters email and password.
   - POST /api/auth/login → backend verifies password, creates session cookie, returns user profile.
   - Frontend stores user in context and redirects to /dashboard.
   - SSO: User clicks Google/Microsoft/SAML. Browser redirect or popup for OAuth flow. Backend handles callback and issues session. Frontend receives session and redirects.
5. Forgot Password:
   - User clicks Forgot Password → /auth/reset (request).
   - Enter email -> POST /api/auth/password-reset/request. Backend sends reset email with single-use token (no account disclosure).
   - User clicks link from mail -> /auth/reset?token=<token>. Frontend verifies token with backend; user enters new password. POST /api/auth/password-reset/confirm to set new password. On success, optionally log user in and redirect to Dashboard.
6. Logout:
   - Protected pages add Logout action that calls POST /api/auth/logout, clears session server-side and clears cookies client-side, then redirect to Landing Page.

## Technical Specifications
- Data Models:

users
- id: uuid (PK)
- email: varchar unique, indexed
- email_verified: boolean default false
- password_hash: varchar nullable (null for SSO-only accounts)
- name: varchar nullable
- role: enum ['user', 'admin'] default 'user'
- created_at, updated_at: timestamps
- last_login_at: timestamp nullable
- locked_until: timestamp nullable

auth_providers
- id: uuid
- user_id: uuid FK users.id
- provider: enum ['google','microsoft','saml']
- provider_id: varchar (unique id from provider)
- metadata: jsonb
- created_at

sessions
- id: uuid
- user_id: uuid
- session_token_hash: varchar
- ip_address, user_agent
- expires_at: timestamp
- created_at, revoked_at: timestamp nullable

email_tokens
- id: uuid
- user_id: uuid
- token_hash: varchar
- type: enum['email_verification','password_reset']
- expires_at: timestamp
- used_at: timestamp nullable
- created_at

audit_logs
- id: uuid
- user_id: uuid nullable
- event: varchar
- ip_address, user_agent
- metadata: jsonb
- created_at

- API Endpoints (examples; implement JSON responses and status codes):
  - POST /api/auth/signup
    - body: { email, password, name? }
    - returns: 201, { success: true, needsVerification: true }
  - POST /api/auth/login
    - body: { email, password }
    - returns: 200, sets httpOnly cookie, { success: true, user: { id, email, name, role, email_verified } }
  - POST /api/auth/logout
    - invalidates session, clears cookie
  - GET /api/auth/me
    - returns current user or 401
  - POST /api/auth/password-reset/request
    - body: { email }
    - returns 200 always { success: true } (to avoid enumeration)
  - POST /api/auth/password-reset/confirm
    - body: { token, newPassword }
    - returns 200, optionally sets session
  - POST /api/auth/verify/resend
    - body: { email }
    - returns 200
  - GET /api/auth/verify/check
    - returns verification status for logged-in user or for email query param with token id
  - GET /api/auth/oauth/:provider
    - redirects to provider auth URL
  - GET /api/auth/oauth/:provider/callback
    - exchange code, create session, redirect to frontend success URL
  - POST /api/auth/saml/acs
    - process SAML assertion
- Security
  - All sensitive endpoints served over HTTPS only.
  - Hash tokens with SHA-256 before storing.
  - Use bcrypt/argon2 for password hashes.
  - Apply rate-limiting middleware to signup/login/password-reset endpoints.
  - Enforce CSRF tokens if using cookie sessions; otherwise use secure token authentication.
  - Validate redirect URLs to prevent open redirect vulnerabilities.
- Validation rules:
  - Email: required, RFC 5322 basic format, normalize by lowercasing and trimming.
  - Password: min 10 chars, at least one uppercase, one lowercase, one digit, one special char. No common passwords allowed (check against a top 10k list).
  - Name: optional, max 100 chars.
  - Terms checkbox required on signup.

## Acceptance Criteria
- [ ] A responsive, accessible /auth page exists with toggle tabs for Login and Signup that match the provided visual style and color palette.
- [ ] Email/password signup creates a user, sends a verification email with a single-use secure token, and redirects to Email Verification page.
- [ ] Signup prevents duplicate accounts by email and enforces password policy and Terms acceptance.
- [ ] Login with email/password returns a secured session (httpOnly cookie or secure token), updates last_login_at, and redirects to Dashboard.
- [ ] SSO flows for Google and Microsoft initiate properly, create or link users, mark email as verified for trusted providers, and return a session.
- [ ] Password reset request sends email (no user enumeration), and reset link allows changing password with proper token validation; token is single-use and expires.
- [ ] Email Verification page supports resend (with 60s cooldown) and polls server for status change and auto-redirects after verification.
- [ ] Security controls are implemented: password hashing, token hashing, rate limiting, account lockout, secure cookies, CSRF protection where applicable.
- [ ] Landing Page matches design tokens, contains hero, features, pricing, and CTAs that open signup or demo agent links.

## UI/UX Guidelines
Apply the project's design system. Use deep charcoal backgrounds (#1A1A1F / #141416) with interactive card backgrounds (#202026 / #23232C) and neon accents (#4FFF8F, #FF7A1B, #50B6FF). Components must have rounded corners (12-16px), subtle drop shadows, and glowing/hove micro-interactions. Spacing should be generous (24-32px gutters). Use a modern geometric sans-serif (Inter-like). Ensure high contrast white headings (#FFFFFF) and secondary text (#D3D3D3). Buttons are pill-shaped and primary in neon green.

Visual micro-specs:
- AuthCard max-width 520px centered on screen with left or top-aligned logo and title.
- Tabs: 2 options, height ~48px, active tab shows neon underline and 8px glow shadow.
- Inputs: height 48px, inner padding 12px, label above input, placeholder lighter grey (#A5A5B5). On focus: inner shadow and faint neon glow.
- Password strength meter: 6px height bar under password input with color interpolation (red → yellow → green) and label "Weak / Okay / Strong".
- SSO Buttons: icons on left, text centered, subtle divider between icon and text, hover glows.
- Error states: inline text in red (#FF4C4C) with small icon, fields show thin red border.

Design Accessibility:
- Contrast ratios compliant (WCAG AA for text).
- Provide focus outlines (thin neon glow or 2px ring) for keyboard users.
- Ensure all color-coded statuses have text equivalents (icons or labels).

Design Philosophy adherence:
- Keep the aesthetic ultra-minimalist, dark-first, neon accents used sparingly for emphasis, and micro-interactions to show responsiveness.
- Maintain modular components so auth views can be re-used inside other flows (e.g., invite flows in admin panel).

---

Deliverable checklist for the developer/AI agent:
- Implement frontend pages and components listed under Frontend.
- Implement backend routes, models, and email sending for verification and resets.
- Provide SQL migrations for DB tables.
- Provide environment/config documentation for OAuth (client ids/secrets), SMTP, and SAML endpoints.
- Write unit and integration tests for API endpoints (signup, login, reset, verify) and E2E tests for the full auth flows.
- Provide a short README with steps to run locally (migrations, env vars, starting dev servers) and instructions for testing email links (e.g., using Mailtrap or local SMTP capture). for style.

CRITICAL DESIGN REQUIREMENTS:
- You MUST follow ALL design principles and patterns specified in the Design Reference above
- Do NOT deviate from the design specifications without explicit user permission
- Implement ALL visual design elements (colors, typography, spacing, shadows, animations) as specified
- Follow the layout patterns and component designs exactly as documented
- Ensure all interactions and micro-animations match the reference specifications

CRITICAL TECHNICAL REQUIREMENTS:
- React 18.3.1, React Router 6.30.1
- Tailwind CSS v3 with tailwind.config.js and custom keyframes
- @tailwindcss/typography plugin for rich text content
- Tailwind CSS animations (NOT Motion library or framer-motion)
- Sonner for toasts
- Recharts for data visualization
- Native fetch() with API utilities in src/lib/api.ts
- Design system with CSS custom properties
- Use RGB color values for theming
- When Supabase is configured: use Edge Functions for LLM and server-only logic; never expose API keys in the client

=== TASK ===
# Signup / Login

## Overview
Build a complete authentication system and public landing pages for the Conversational Agent Form Builder. This includes a combined Signup/Login entry page with email/password and SSO (Google, Microsoft, SAML) options, secure backend authentication and session management for users and admins, password reset flow via secure token links, email verification flow with resend and polling, and a marketing Landing Page with CTAs. All UI should follow the provided dark-mode, neon-accent design system and integrate into the project's agent/dashboard flow (successful auth redirects to Dashboard).

## Page Description (Full Detail)
This bundle comprises the Authentication entry (Signup / Login), Password Reset, Email Verification, and public Landing Page used by visitors and prospective customers.

What this page is:
- The Signup / Login page is the user's first entry point to create accounts or authenticate. It must support classic email/password flows and multiple SSO integrations (Google, Microsoft, SAML for enterprise).
- Password Reset page allows users to request a reset email and set a new password via a time-limited secure token.
- Email Verification page displayed after signup to instruct users to verify their email. It includes a resend verification button and a background polling mechanism to detect verification and auto-redirect.
- Landing Page is a public marketing page describing the product (agent form builder), value propositions, pricing, feature highlights, and CTAs to sign up or try a demo agent (public demo link).

Goals:
- Provide a secure, accessible, and friction-minimized onboarding/authentication experience that matches the product's modern, dark-mode aesthetic.
- Allow admins and regular users to log in, persist secure sessions, and handle SSO and password flows.
- Ensure email verification and password reset are secure (short-lived tokens, single-use links).
- Integrate redirects to Dashboard or demo agent links after successful auth.

Features connected:
- Core User Authentication: signup, login, logout, session handling (JWT or server session), role-based admin access, SSO flows.
- Email services: transactional emails for verification and password-reset (email templates consistent with design).
- Security and monitoring: rate limiting, account lockout for repeated failures, CAPTCHA (optional) on signup if needed.
- Audit logging for account events (signup, verify, login, failed logins, password reset).

UI elements & visual guidance:
- Auth Card: centered card on dark background (#1A1A1F / #141416), card background #202026 or #23232C, rounded 12-16px, subtle drop shadow, internal padding 24-28px.
- Header: product logo (left, neon accent), page title (Login or Create account) in white semibold (600).
- Tabs: two tabs to switch between Login and Signup (tabbed or segmented control). Active tab highlighted with neon green (#4FFF8F) underline or glow.
- Forms: Email input, password input, confirm password (only on signup), password strength meter (progress bar with color changes: red → yellow → green), inline validation messages in muted grey/red.
- SSO Buttons: pill-shaped buttons for Google, Microsoft, and "Enterprise SSO (SAML)". Each with an icon and subtle glow on hover (accent colors).
- Terms Checkbox: checkbox with link to Terms & Privacy, required on signup.
- Forgot Password: small link under login form to Password Reset page.
- Primary Action Buttons: pill-shaped, primary color neon green (#4FFF8F) for main actions, secondary grey buttons for alternatives.
- Success Toast/Redirect: short success toast in top-right with green accent then redirect to Dashboard (/dashboard) or previous intended URL.
- Password Reset Page: two sub-pages/views: (1) Request Reset: email input + submit; (2) Set New Password: accessed by secure link token. Both in same card style.
- Email Verification Page: card showing "Check your inbox", email displayed obfuscated, "Resend" button with cooldown, "Change email" link, and a background polling indicator (spinner + "Waiting for verification..."). Auto-redirect to Dashboard when verified.
- Landing Page: hero with product value props, feature cards, pricing CTA, testimonials, and actions: "Sign up" (redirect to Signup tab), "Try demo agent" (open a public demo agent in a new tab). Use neon accent highlights across hero and CTA buttons.

API integrations:
- No external API pre-connected in project context. Implement backend endpoints for authentication flows; provide hooks for external SMTP provider and SSO provider configs. Provide /auth/oauth endpoints that will integrate with OAuth providers (Google, Microsoft) and enterprise SAML via configuration.

## Components to Build
- AuthCard component: Tabbed container for Login and Signup forms with accessible keyboard navigation and animated tab indicator.
- EmailInput, PasswordInput components: inputs with inline validation, placeholder, label, tooltip, and password strength meter.
- SSOButtons component: Google, Microsoft, SAML button variants with icon, accessible labels, and click handlers.
- TermsCheckbox component: linked policy modal or external link, required enforcement.
- ForgotPasswordLink component: navigates to Password Reset Request view.
- PasswordStrengthMeter component: visual meter with color coding and textual hints.
- Toast / GlobalNotification component: success/error messages consistent with visual style.
- PasswordResetRequestView: email submission form.
- PasswordResetSetView: set new password, validate token, show time-left and reset result.
- EmailVerificationView: shows verified/unverified states, resend flow with cooldown, polling to backend for status.
- LandingPage components: Hero, FeaturesList, PricingCards, Testimonials, CTAs.
- API Client module: central HTTP client that handles session tokens, CSRF headers, and error handling.
- Route Guards: frontend route protection and redirect-to-login for protected routes.

## Implementation Requirements

### Frontend
- Stack: React (hooks), TypeScript, CSS-in-JS or Tailwind-like utility (deliver styled components that match design tokens). Use a router (React Router) and state management adequate for auth (Context or Redux).
- Pages:
  - /auth (default shows login tab, with ?tab=signup or #signup to deep link)
  - /auth/reset (request)
  - /auth/reset?token=<token> (set new password)
  - /auth/verify (Email Verification page)
  - / (Landing Page)
- Interactions:
  - Real-time input validation (email format, password policy: min 10 chars, include uppercase, lowercase, digit, special char)
  - Password strength meter updates as user types (visual + text).
  - Submit buttons disabled during requests; display loader animation.
  - SSO: clicking SSO buttons starts OAuth flow by opening /auth/oauth/:provider or redirecting. Support popup fallback.
  - On Signup success: show Email Verification page and prevent Dashboard access until verified (unless allow pre-verified access via setting).
  - Email Verification Page:
    - Poll endpoint /auth/me or /auth/verification-status every 5s (exponential backoff after several attempts) to detect when verified, then auto-redirect.
    - Resend button with 60s cooldown, show cooldown timer and success toast.
  - Password Reset:
    - Request: send email; show generic messaging (do not reveal whether email exists).
    - Set New Password: validate token with backend; show remaining time or invalid/expired flows, and link to request a new reset.
- Accessibility: All interactive elements keyboard accessible, proper aria-labels, form labels, error announcements.

### Backend
- Stack: Node.js + TypeScript (Express / Fastify / Nest recommended); SQL DB (Postgres) or similar. Provide SQL schema snippets and migration steps.
- Authentication:
  - Use secure password hashing (bcrypt with cost >=12 or argon2).
  - Issue sessions via HTTP-only, Secure cookies with SameSite=lax OR JWT stored in httpOnly cookies (refresh token pattern recommended).
  - Session inactivity TTL: configurable (recommend 14 days persistent, shorter for admin sessions).
  - Session revocation on logout.
- Email tokens:
  - Email verification tokens: cryptographically secure, single-use, expire in 24 hours.
  - Password reset tokens: cryptographically secure, single-use, expire in 1 hour.
  - Tokens stored hashed in DB (so if DB is compromised tokens are not usable).
- SSO:
  - OAuth2 flows for Google and Microsoft (server-side exchange using client secret).
  - SAML for enterprises: endpoint to receive SAML Assertion Consumer Service (ACS), map attributes to account or create new user with admin approval flow.
  - On SSO authentication, if email exists link provider to account; otherwise create user record and mark email as verified (for trusted providers).
- APIs:
  - /api/auth/signup (POST)
  - /api/auth/login (POST)
  - /api/auth/logout (POST)
  - /api/auth/me (GET)
  - /api/auth/password-reset/request (POST)
  - /api/auth/password-reset/confirm (POST) — token + new password
  - /api/auth/verify/resend (POST)
  - /api/auth/verify/check (GET) or use /api/auth/me
  - /api/auth/oauth/:provider (GET) — redirect to provider
  - /api/auth/oauth/:provider/callback (GET) — provider redirects here
  - /api/auth/saml/acs (POST) — SAML ACS
- DB tables:
  - users, auth_providers (SSO links), sessions, email_tokens (verification, reset), audit_logs
- Email sending:
  - Template engine for transactional emails with staging config and ability to plug SMTP / SES / SendGrid.
- Security:
  - Rate-limiting endpoints (signup, login, password reset) per IP and per account.
  - Account lockout after configurable failed attempts (e.g., 5 attempts in 15 minutes).
  - ReCAPTCHA or hCaptcha support on signup optionally, pluggable.
  - CSRF protection on state-changing endpoints (for cookie-based sessions).
  - Input validation and sanitization.
  - Proper CORS configuration for public client origins.
  - Logging and monitoring of suspicious auth activity.

### Integration
- Frontend and backend communicate over HTTPS using JSON API. The frontend should expect and handle the following:
  - 200/201 on success with structured body { success: true, data: {...} }.
  - 400 validation errors with { errors: [{ field, message }] }.
  - 401/403 for unauthorized/forbidden to trigger logout and redirect to login.
- On login/signup success:
  - Backend sets httpOnly cookie (session) or returns tokens.
  - Frontend calls /api/auth/me to fetch user profile and roles and uses route guard to navigate to /dashboard.
- SSO Integration:
  - Frontend triggers /api/auth/oauth/google (server returns redirect URL). For popup flow, the frontend opens a new window and polls for completion (postMessage or server-side session poll).
- Email Verification:
  - After signup, backend returns a status indicating verification required. Frontend shows EmailVerificationView with polling hitting /api/auth/verify/check or /api/auth/me.
- Password Reset:
  - Backend issues email with one-time link: https://<APP_HOST>/auth/reset?token=<token>. Frontend reads token from URL and calls /api/auth/password-reset/confirm.

## User Experience Flow
1. Landing Page visitor:
   - Sees hero with product summary and CTA "Sign up" and "Try demo agent".
   - Click "Try demo agent" opens public agent URL in new tab (no auth needed).
   - Click "Sign up" lands on /auth with signup tab active.
2. Signup:
   - User fills email, password, confirm password, accepts Terms.
   - Client validates inputs, shows password strength meter.
   - On submit, POST /api/auth/signup.
   - Backend creates user (password hashed), creates verification token, sends verification email, returns success.
   - Frontend navigates to /auth/verify and displays verification instructions. Show obfuscated email and resend button (60s cooldown).
3. Email Verification:
   - User clicks link in email → opens frontend route (/auth/verify?token=... or hits backend to verify token).
   - Backend verifies token, marks email_verified = true, logs event, and sets session cookie (optionally logs them in).
   - If user clicked email link, they should be auto-redirected to Dashboard.
   - If they remain on EmailVerificationView, background polling detects verification and redirects.
4. Login:
   - User selects Login tab, enters email and password.
   - POST /api/auth/login → backend verifies password, creates session cookie, returns user profile.
   - Frontend stores user in context and redirects to /dashboard.
   - SSO: User clicks Google/Microsoft/SAML. Browser redirect or popup for OAuth flow. Backend handles callback and issues session. Frontend receives session and redirects.
5. Forgot Password:
   - User clicks Forgot Password → /auth/reset (request).
   - Enter email -> POST /api/auth/password-reset/request. Backend sends reset email with single-use token (no account disclosure).
   - User clicks link from mail -> /auth/reset?token=<token>. Frontend verifies token with backend; user enters new password. POST /api/auth/password-reset/confirm to set new password. On success, optionally log user in and redirect to Dashboard.
6. Logout:
   - Protected pages add Logout action that calls POST /api/auth/logout, clears session server-side and clears cookies client-side, then redirect to Landing Page.

## Technical Specifications
- Data Models:

users
- id: uuid (PK)
- email: varchar unique, indexed
- email_verified: boolean default false
- password_hash: varchar nullable (null for SSO-only accounts)
- name: varchar nullable
- role: enum ['user', 'admin'] default 'user'
- created_at, updated_at: timestamps
- last_login_at: timestamp nullable
- locked_until: timestamp nullable

auth_providers
- id: uuid
- user_id: uuid FK users.id
- provider: enum ['google','microsoft','saml']
- provider_id: varchar (unique id from provider)
- metadata: jsonb
- created_at

sessions
- id: uuid
- user_id: uuid
- session_token_hash: varchar
- ip_address, user_agent
- expires_at: timestamp
- created_at, revoked_at: timestamp nullable

email_tokens
- id: uuid
- user_id: uuid
- token_hash: varchar
- type: enum['email_verification','password_reset']
- expires_at: timestamp
- used_at: timestamp nullable
- created_at

audit_logs
- id: uuid
- user_id: uuid nullable
- event: varchar
- ip_address, user_agent
- metadata: jsonb
- created_at

- API Endpoints (examples; implement JSON responses and status codes):
  - POST /api/auth/signup
    - body: { email, password, name? }
    - returns: 201, { success: true, needsVerification: true }
  - POST /api/auth/login
    - body: { email, password }
    - returns: 200, sets httpOnly cookie, { success: true, user: { id, email, name, role, email_verified } }
  - POST /api/auth/logout
    - invalidates session, clears cookie
  - GET /api/auth/me
    - returns current user or 401
  - POST /api/auth/password-reset/request
    - body: { email }
    - returns 200 always { success: true } (to avoid enumeration)
  - POST /api/auth/password-reset/confirm
    - body: { token, newPassword }
    - returns 200, optionally sets session
  - POST /api/auth/verify/resend
    - body: { email }
    - returns 200
  - GET /api/auth/verify/check
    - returns verification status for logged-in user or for email query param with token id
  - GET /api/auth/oauth/:provider
    - redirects to provider auth URL
  - GET /api/auth/oauth/:provider/callback
    - exchange code, create session, redirect to frontend success URL
  - POST /api/auth/saml/acs
    - process SAML assertion
- Security
  - All sensitive endpoints served over HTTPS only.
  - Hash tokens with SHA-256 before storing.
  - Use bcrypt/argon2 for password hashes.
  - Apply rate-limiting middleware to signup/login/password-reset endpoints.
  - Enforce CSRF tokens if using cookie sessions; otherwise use secure token authentication.
  - Validate redirect URLs to prevent open redirect vulnerabilities.
- Validation rules:
  - Email: required, RFC 5322 basic format, normalize by lowercasing and trimming.
  - Password: min 10 chars, at least one uppercase, one lowercase, one digit, one special char. No common passwords allowed (check against a top 10k list).
  - Name: optional, max 100 chars.
  - Terms checkbox required on signup.

## Acceptance Criteria
- [ ] A responsive, accessible /auth page exists with toggle tabs for Login and Signup that match the provided visual style and color palette.
- [ ] Email/password signup creates a user, sends a verification email with a single-use secure token, and redirects to Email Verification page.
- [ ] Signup prevents duplicate accounts by email and enforces password policy and Terms acceptance.
- [ ] Login with email/password returns a secured session (httpOnly cookie or secure token), updates last_login_at, and redirects to Dashboard.
- [ ] SSO flows for Google and Microsoft initiate properly, create or link users, mark email as verified for trusted providers, and return a session.
- [ ] Password reset request sends email (no user enumeration), and reset link allows changing password with proper token validation; token is single-use and expires.
- [ ] Email Verification page supports resend (with 60s cooldown) and polls server for status change and auto-redirects after verification.
- [ ] Security controls are implemented: password hashing, token hashing, rate limiting, account lockout, secure cookies, CSRF protection where applicable.
- [ ] Landing Page matches design tokens, contains hero, features, pricing, and CTAs that open signup or demo agent links.

## UI/UX Guidelines
Apply the project's design system. Use deep charcoal backgrounds (#1A1A1F / #141416) with interactive card backgrounds (#202026 / #23232C) and neon accents (#4FFF8F, #FF7A1B, #50B6FF). Components must have rounded corners (12-16px), subtle drop shadows, and glowing/hove micro-interactions. Spacing should be generous (24-32px gutters). Use a modern geometric sans-serif (Inter-like). Ensure high contrast white headings (#FFFFFF) and secondary text (#D3D3D3). Buttons are pill-shaped and primary in neon green.

Visual micro-specs:
- AuthCard max-width 520px centered on screen with left or top-aligned logo and title.
- Tabs: 2 options, height ~48px, active tab shows neon underline and 8px glow shadow.
- Inputs: height 48px, inner padding 12px, label above input, placeholder lighter grey (#A5A5B5). On focus: inner shadow and faint neon glow.
- Password strength meter: 6px height bar under password input with color interpolation (red → yellow → green) and label "Weak / Okay / Strong".
- SSO Buttons: icons on left, text centered, subtle divider between icon and text, hover glows.
- Error states: inline text in red (#FF4C4C) with small icon, fields show thin red border.

Design Accessibility:
- Contrast ratios compliant (WCAG AA for text).
- Provide focus outlines (thin neon glow or 2px ring) for keyboard users.
- Ensure all color-coded statuses have text equivalents (icons or labels).

Design Philosophy adherence:
- Keep the aesthetic ultra-minimalist, dark-first, neon accents used sparingly for emphasis, and micro-interactions to show responsiveness.
- Maintain modular components so auth views can be re-used inside other flows (e.g., invite flows in admin panel).

---

Deliverable checklist for the developer/AI agent:
- Implement frontend pages and components listed under Frontend.
- Implement backend routes, models, and email sending for verification and resets.
- Provide SQL migrations for DB tables.
- Provide environment/config documentation for OAuth (client ids/secrets), SMTP, and SAML endpoints.
- Write unit and integration tests for API endpoints (signup, login, reset, verify) and E2E tests for the full auth flows.
- Provide a short README with steps to run locally (migrations, env vars, starting dev servers) and instructions for testing email links (e.g., using Mailtrap or local SMTP capture).

=== SUCCESS CRITERIA ===
# Success Criteria Checklist

## Code Quality

### TypeScript
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] All functions and components have proper type definitions
- [ ] No `any` types used (use `unknown` if type is truly unknown)
- [ ] Props interfaces defined for all components
- [ ] API responses have type definitions

### Code Standards
- [ ] All imports use path aliases (@/ prefix)
- [ ] Components follow the established naming convention
- [ ] Files are organized in correct directories
- [ ] No unused imports or variables
- [ ] Consistent code formatting

## Component Implementation

### UI Components
- [ ] Use shadcn/ui components (Button, Card, Input, etc.) instead of building from scratch
- [ ] All interactive elements have hover states
- [ ] Components use the `cn()` utility for class merging
- [ ] Proper TypeScript props interfaces defined
- [ ] Components are responsive (mobile, tablet, desktop)

### Animations
- [ ] Motion library used for all animations (NOT framer-motion)
- [ ] Page transitions implemented with fade/slide
- [ ] Interactive elements have whileHover/whileTap animations
- [ ] List items use stagger animations where appropriate
- [ ] Animations respect `prefers-reduced-motion`

### Icons
- [ ] Lucide React icons used consistently
- [ ] Icons have consistent sizing (h-4 w-4, h-5 w-5, h-6 w-6)
- [ ] Icon colors match design system (text-primary, text-muted-foreground)

## Data Management

### React Query
- [ ] All data fetching uses React Query hooks
- [ ] Query keys follow the established pattern
- [ ] Mutations invalidate related queries
- [ ] Loading and error states handled
- [ ] Optimistic updates implemented where appropriate

### Forms
- [ ] Forms use react-hook-form
- [ ] Validation uses Zod schemas
- [ ] Error messages display properly
- [ ] Form submission shows loading state
- [ ] Success/error feedback via toast notifications

### API Layer
- [ ] API functions in src/api/ directory
- [ ] Axios used for HTTP requests
- [ ] Proper error handling with try/catch
- [ ] Auth tokens handled by interceptors
- [ ] Type-safe API function signatures

## User Experience

### Notifications
- [ ] Sonner toasts used for all notifications
- [ ] Success actions show success toast
- [ ] Errors show descriptive error messages
- [ ] Loading states show toast.loading()

### Loading States
- [ ] Skeleton loaders shown during data fetch
- [ ] Buttons show loading state during submission
- [ ] Disabled state applied during async operations

### Error Handling
- [ ] Network errors caught and displayed
- [ ] User-friendly error messages (no stack traces)
- [ ] Fallback UI for error states
- [ ] No unhandled promise rejections

## Navigation

### Route Accessibility
- [ ] All pages have routes defined in router configuration
- [ ] Every page is accessible through navigation (menu, sidebar, or direct URL)
- [ ] Main pages (Dashboard, Home, Settings, etc.) accessible from primary navigation
- [ ] Secondary pages accessible through contextual navigation or direct links
- [ ] Deep-linked pages have breadcrumbs or back navigation
- [ ] 404/Not Found page implemented for invalid routes
- [ ] Protected routes have proper authentication checks
- [ ] Navigation state persists across page refreshes where appropriate

### Navigation UX
- [ ] Active route highlighted in navigation menu
- [ ] Clear visual hierarchy in navigation structure
- [ ] Mobile navigation is accessible and usable
- [ ] Navigation items have hover/focus states
- [ ] Nested routes show parent-child relationships
- [ ] User can always return to main areas (Dashboard/Home)

## Styling

### Tailwind CSS
- [ ] Tailwind v3 classes used
- [ ] HSL color variables from design system
- [ ] Custom CSS properties used where defined
- [ ] Responsive breakpoints: mobile-first approach
- [ ] Dark mode support via CSS variables

### Design System
- [ ] Colors use theme variables (primary, secondary, accent)
- [ ] Spacing uses Tailwind scale (p-4, gap-6, etc.)
- [ ] Border radius uses theme values (rounded-lg)
- [ ] Shadows use theme values (shadow-card)
- [ ] Typography follows Inter font system

## Accessibility

- [ ] Semantic HTML elements used
- [ ] Buttons have descriptive labels
- [ ] Forms have proper labels
- [ ] Focus states visible on interactive elements
- [ ] Color contrast meets WCAG standards

## Performance

- [ ] No console.log statements in production code
- [ ] No console errors in browser
- [ ] Images optimized (WebP, lazy loading)
- [ ] Large lists use virtualization if needed
- [ ] React Query cache configured appropriately

## Testing Readiness

- [ ] Components structured for easy testing
- [ ] Business logic separated from presentation
- [ ] Mock-friendly API layer
- [ ] No hardcoded values that should be configurable
- [ ] Environment variables properly configured

## Final Checks

- [ ] Code builds without errors (`npm run build`)
- [ ] Development server runs without errors (`npm run dev`)
- [ ] No TypeScript errors in editor
- [ ] Browser console is clean (no errors or warnings)
- [ ] All functionality works as expected
- [ ] Code follows existing project patterns
- [ ] Changes are consistent with the rest of the codebase



IMPORTANT: ALL styling and design decisions must follow the Design Reference section above EXACTLY. Do not make arbitrary design choices.

Analyze the existing project structure and implement the task following the patterns already established. Ensure all success criteria are met.